<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="generator" content="http://txt2tags.org">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>NameTag: Name Entity Recognizer</title>
</head>
<body>

<div class="header" id="header">
<h1>NameTag: Name Entity Recognizer</h1>
<h2>Version 1.1.3-devel</h2>
</div>

<div class="toc">

  <ol>
  <li><a href="#introduction">Introduction</a>
  </li>
  <li><a href="#online">Online</a>
  </li>
  <li><a href="#release">Release</a>
    <ul>
    <li><a href="#download">3.1. Download</a>
      <ul>
      <li><a href="#language_models">3.1.1. Language Models</a>
      </li>
      </ul>
    </li>
    <li><a href="#license">3.2. License</a>
    </li>
    <li><a href="#platforms_and_requirements">3.3. Platforms and Requirements</a>
    </li>
    </ul>
  </li>
  <li><a href="#installation">NameTag Installation</a>
    <ul>
    <li><a href="#requirements">4.1. Requirements</a>
    </li>
    <li><a href="#compilation">4.2. Compilation</a>
      <ul>
      <li><a href="#compilation_platforms">4.2.1. Platforms</a>
      </li>
      <li><a href="#compilation_further_details">4.2.2. Further Details</a>
      </li>
      </ul>
    </li>
    <li><a href="#other_language_bindings">4.3. Other language bindings</a>
      <ul>
      <li><a href="#csharp_installation">4.3.1. C#</a>
      </li>
      <li><a href="#java_installation">4.3.2. Java</a>
      </li>
      <li><a href="#perl_installation">4.3.3. Perl</a>
      </li>
      <li><a href="#python_installation">4.3.4. Python</a>
      </li>
      </ul>
    </li>
    </ul>
  </li>
  <li><a href="#users_manual">NameTag User's Manual</a>
    <ul>
    <li><a href="#czech-cnec">5.1. Czech NameTag Models</a>
      <ul>
      <li><a href="#czech-cnec_download">5.1.1. Download</a>
      </li>
      <li><a href="#czech-cnec_acknowledgements">5.1.2. Acknowledgements</a>
      </li>
      <li><a href="#czech-cnec20_model">5.1.3. Czech Named Entity Corpus 2.0 Model</a>
      </li>
      <li><a href="#czech-cnec11_model">5.1.4. Czech Named Entity Corpus 1.1 Model</a>
      </li>
      </ul>
    </li>
    <li><a href="#english-conll">5.2. English NameTag Models</a>
      <ul>
      <li><a href="#english-conll_acknowledgements">5.2.1. Acknowledgements</a>
      </li>
      <li><a href="#english-conll_model">5.2.2. English Model</a>
      </li>
      </ul>
    </li>
    <li><a href="#run_ner">5.3. Running the Recognizer</a>
      <ul>
      <li><a href="#run_ner_input_formats">5.3.1. Input Formats</a>
      </li>
      <li><a href="#run_ner_output_formats">5.3.2. Output Formats</a>
      </li>
      </ul>
    </li>
    <li><a href="#run_tokenizer">5.4. Running the Tokenizer</a>
      <ul>
      <li><a href="#run_tokenizer_output_formats">5.4.1. Output Formats</a>
      </li>
      </ul>
    </li>
    <li><a href="#rest_server">5.5. Running REST Server</a>
    </li>
    <li><a href="#custom_models">5.6. Training of Custom Models</a>
      <ul>
      <li><a href="#training_data">5.6.1. Training data</a>
      </li>
      <li><a href="#tagger">5.6.2. Tagger</a>
      </li>
      <li><a href="#feature_templates">5.6.3. Feature Templates</a>
      </li>
      <li><a href="#train_ner">5.6.4. Running train_ner</a>
      </li>
      </ul>
    </li>
    </ul>
  </li>
  <li><a href="#api_reference">NameTag API Reference</a>
    <ul>
    <li><a href="#versioning">6.1. NameTag Versioning</a>
    </li>
    <li><a href="#string_piece">6.2. Struct string_piece</a>
    </li>
    <li><a href="#token_range">6.3. Struct token_range</a>
    </li>
    <li><a href="#named_entity">6.4. Struct named_entity</a>
    </li>
    <li><a href="#version">6.5. Class version</a>
      <ul>
      <li><a href="#version_current">6.5.1. version::current</a>
      </li>
      </ul>
    </li>
    <li><a href="#tokenizer">6.6. Class tokenizer</a>
      <ul>
      <li><a href="#tokenizer_set_text">6.6.1. tokenizer::set_text</a>
      </li>
      <li><a href="#tokenizer_next_sentence">6.6.2. tokenizer::next_sentence</a>
      </li>
      <li><a href="#tokenizer_new_vertical_tokenizer">6.6.3. tokenizer::new_vertical_tokenizer</a>
      </li>
      </ul>
    </li>
    <li><a href="#ner">6.7. Class ner</a>
      <ul>
      <li><a href="#ner_load_cstring">6.7.1. ner::load(const char*)</a>
      </li>
      <li><a href="#ner_load_istream">6.7.2. ner::load(istream&amp;)</a>
      </li>
      <li><a href="#ner_recognize">6.7.3. ner::recognize</a>
      </li>
      <li><a href="#ner_entity_types">6.7.4. ner::entity_types</a>
      </li>
      <li><a href="#ner_gazetteers">6.7.5. ner::gazetteers</a>
      </li>
      <li><a href="#ner_new_tokenizer">6.7.6. ner::new_tokenizer</a>
      </li>
      </ul>
    </li>
    <li><a href="#cpp_bindings_api">6.8. C++ Bindings API</a>
      <ul>
      <li><a href="#bindings_helper_structures">6.8.1. Helper Structures</a>
      </li>
      <li><a href="#bindings_main_classes">6.8.2. Main Classes</a>
      </li>
      </ul>
    </li>
    <li><a href="#csharp_bindings">6.9. C# Bindings</a>
    </li>
    <li><a href="#java_bindings">6.10. Java Bindings</a>
    </li>
    <li><a href="#perl_bindings">6.11. Perl Bindings</a>
    </li>
    <li><a href="#python_bindings">6.12. Python Bindings</a>
    </li>
    </ul>
  </li>
  <li><a href="#contact">Contact</a>
  </li>
  <li><a href="#nametag_acknowledgements">Acknowledgements</a>
    <ul>
    <li><a href="#publications">8.1. Publications</a>
    </li>
    <li><a href="#bibtex_for_referencing">8.2. Bibtex for referencing</a>
    </li>
    <li><a href="#persistent_identifier">8.3. Persistent Identifier</a>
    </li>
    </ul>
  </li>
  </ol>

</div>
<div class="body" ID="body">

<a id="introduction" name="introduction"></a>
<h1>1. Introduction</h1>

<p>
NameTag is an open-source tool for named entity recognition (NER). NameTag
identifies proper names in text and classifies them into predefined categories,
such as names of persons, locations, organizations, etc. NameTag is distributed
as a standalone tool or a library, along with trained linguistic models. In the
Czech language, NameTag achieves state-of-the-art performance
(<a href="http://ufal.mff.cuni.cz/~straka/papers/2013-tsd_ner.pdf">Straková et al. 2013</a>).
NameTag is a free software under <a href="http://www.mozilla.org/MPL/2.0/">Mozilla Public License 2.0</a>
license and the linguistic models are free for non-commercial use and
distributed under <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA</a>
license, although for some models the original data used to create the model
may impose additional licensing conditions. NameTag is versioned using
<a href="http://semver.org/">Semantic Versioning</a>.
</p>
<p>
Copyright 2016 by Institute of Formal and Applied Linguistics, Faculty of
Mathematics and Physics, Charles University in Prague, Czech Republic.
</p>

<a id="online" name="online"></a>
<h1>2. Online</h1>

<p>
NameTag Web Application is available at <a href="http://lindat.mff.cuni.cz/services/nametag/">http://lindat.mff.cuni.cz/services/nametag/</a>
using <a href="http://lindat.cz">LINDAT/CLARIN infrastructure</a>.
</p>
<p>
NameTag REST Web Service is also available, with the API documentation available at
<a href="http://lindat.mff.cuni.cz/services/udpipe/api-reference.php">http://lindat.mff.cuni.cz/services/udpipe/api-reference.php</a>.
</p>

<a id="release" name="release"></a>
<h1>3. Release</h1>

<a id="download" name="download"></a>
<h2>3.1. Download</h2>

<p>
NameTag releases are available on <a href="http://github.com/ufal/nametag">GitHub</a>, either as
a pre-compiled binary package, or source code only. The binary package contains Linux,
Windows and OS X binaries, Java bindings binary, C# bindings binary and source code of
NameTag and all language bindings. While the binary
packages do not contain compiled Python or Perl bindings, packages for those
languages are available in standard package repositories, i.e. on PyPI and CPAN.
</p>

<ul>
<li><a href="http://github.com/ufal/nametag/releases/latest">Latest release</a>
</li>
<li><a href="http://github.com/ufal/nametag/releases">All releases</a>, <a href="https://github.com/ufal/nametag/blob/master/CHANGES">Changelog</a>
</li>
</ul>

<a id="language_models" name="language_models"></a>
<h3>3.1.1. Language Models</h3>

<p>
To use NameTag, a language model is needed. The language models are available
from <a href="http://www.lindat.cz">LINDAT/CLARIN</a> infrastructure and described further
in the
<a href="#users_manual">NameTag User's Manual</a>.
Currently the following language models are available:
</p>

<ul>
<li>Czech: <a href="http://hdl.handle.net/11858/00-097C-0000-0023-7D42-8">czech-cnec-140304</a> (<a href="http://ufal.mff.cuni.cz/nametag/1/users-manual#czech-cnec">documentation</a>)
</li>
<li>English: <a href="http://hdl.handle.net/11234/1-3118">english-conll-140408</a> (<a href="http://ufal.mff.cuni.cz/nametag/1/users-manual#english-conll">documentation</a>)
</li>
</ul>

<a id="license" name="license"></a>
<h2>3.2. License</h2>

<p>
NameTag is an open-source project and is freely available for non-commercial
purposes. The source code is distributed under
<a href="http://www.mozilla.org/MPL/2.0/">Mozilla Public License 2.0</a>
and the pre-compiled binaries and the associated models and data under
<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA</a>, although for
some models the original data used to create the model may impose additional
licensing conditions.
</p>
<p>
If you use this tool for scientific work, please give credit to us by
referencing <a href="http://ufal.mff.cuni.cz/nametag">NameTag website</a> and
<a href="http://www.aclweb.org/anthology/P/P14/P14-5003.pdf">Straková et al. 2014</a>.
</p>

<a id="platforms_and_requirements" name="platforms_and_requirements"></a>
<h2>3.3. Platforms and Requirements</h2>

<p>
NameTag is available as a standalone tool and as a library for Linux/Windows/OS X.
It does not require any additional libraries. As any supervised machine
learning tool, it needs trained linguistic models to perform named entity
recognition. The models for the Czech language are available with the tool.
</p>

<a id="installation" name="installation"></a>
<h1>4. NameTag Installation</h1>

<p>
NameTag releases are available on <a href="http://github.com/ufal/nametag">GitHub</a>, either as
a pre-compiled binary package, or source code only. The binary package contains Linux,
Windows and OS X binaries, Java bindings binary, C# bindings binary and source code of
NameTag and all language bindings. While the binary
packages do not contain compiled Python or Perl bindings, packages for those
languages are available in standard package repositories, i.e. on PyPI and CPAN.
</p>
<p>
To use NameTag, a language model is needed.
<a href="http://ufal.mff.cuni.cz/nametag/1#language_models">Here is a list of available language models</a>.
</p>
<p>
If you want to compile NameTag manually, sources are available on on
<a href="http://github.com/ufal/nametag">GitHub</a>, both in the
<a href="http://github.com/ufal/nametag/releases">pre-compiled binary package releases</a>
and in the repository itself.
</p>

<a id="requirements" name="requirements"></a>
<h2>4.1. Requirements</h2>

<ul>
<li><code>G++ 4.7</code> or newer, <code>clang 3.2</code> or newer, Visual C++ 2015 or newer
</li>
<li><code>make</code>
</li>
<li><code>SWIG</code> for language bindings other than <code>C++</code>
</li>
</ul>

<a id="compilation" name="compilation"></a>
<h2>4.2. Compilation</h2>

<p>
To compile NameTag, run <code>make</code> in the <code>src</code> directory.
</p>
<p style="margin-bottom:0">
Make targets and options:
</p>
<ul style="margin-top:0">
<li><code>exe</code>: compile the binaries (default)
</li>
<li><code>server</code>: compile the REST server
</li>
<li><code>lib</code>: compile NameTag library (decoding only)
</li>
<li><code>BITS=32</code> or <code>BITS=64</code>: compile for specified 32-bit or 64-bit architecture instead of the default one
</li>
<li><code>MODE=release</code>: create release build which statically links the C++ runtime and uses LTO
</li>
<li><code>MODE=debug</code>: create debug build
</li>
<li><code>MODE=profile</code>: create profile build
</li>
</ul>

<a id="compilation_platforms" name="compilation_platforms"></a>
<h3>4.2.1. Platforms</h3>

<p style="margin-bottom:0">
Platform can be selected using one of the following options:
</p>
<ul style="margin-top:0">
<li><code>PLATFORM=linux</code>, <code>PLATFORM=linux-gcc</code>: gcc compiler on Linux operating system, default on Linux
</li>
<li><code>PLATFORM=linux-clang</code>: clang compiler on Linux, must be selected manually
</li>
<li><code>PLATFORM=macos</code>, <code>PLATFORM=macos-clang</code>: clang compiler on OS X, default on OS X; <code>BITS=32+64</code> enables multiarch build
</li>
<li><code>PLATFORM=win</code>, <code>PLATFORM=win-gcc</code>: gcc compiler on Windows (TDM-GCC is well tested), default on Windows
</li>
<li><code>PLATFORM=win-vs</code>: Visual C++ 2015 compiler on Windows, must be selected manually; note that the
  <code>cl.exe</code> compiler must be already present in <code>PATH</code> and corresponding <code>BITS=32</code> or <code>BITS=64</code>
  must be specified
</li>
</ul>

<p>
Either POSIX shell or Windows CMD can be used as shell, it is detected automatically.
</p>

<a id="compilation_further_details" name="compilation_further_details"></a>
<h3>4.2.2. Further Details</h3>

<p>
MorphoDiTa uses <a href="http://github.com/ufal/cpp_builtem">C++ BuilTem system</a>,
please refer to its manual if interested in all supported options.
</p>

<a id="other_language_bindings" name="other_language_bindings"></a>
<h2>4.3. Other language bindings</h2>

<a id="csharp_installation" name="csharp_installation"></a>
<h3>4.3.1. C#</h3>

<p>
Binary C# bindings are available in NameTag binary packages.
</p>
<p>
To compile C# bindings manually, run <code>make</code> in the <code>bindings/csharp</code>
directory, optionally with the options described in NameTag Installation.
</p>

<a id="java_installation" name="java_installation"></a>
<h3>4.3.2. Java</h3>

<p>
Binary Java bindings are available in NameTag binary packages.
</p>
<p>
To compile Java bindings manually, run <code>make</code> in the <code>bindings/java</code>
directory, optionally with the options described in NameTag Installation.
Java 6 and newer is supported.
</p>
<p style="margin-bottom:0">
The Java installation specified in the environment variable <code>JAVA_HOME</code> is
used.  If the environment variable does not exist, the <code>JAVA_HOME</code> can be
specified using
</p>
<pre style="margin-top:0">
make JAVA_HOME=path_to_Java_installation
</pre>

<a id="perl_installation" name="perl_installation"></a>
<h3>4.3.3. Perl</h3>

<p>
The Perl bindings are available as <code>Ufal-NameTag</code> package on CPAN.
</p>
<p>
To compile Perl bindings manually, run <code>make</code> in the <code>bindings/perl</code>
directory, optionally with the options described in NameTag Installation.
Perl 5.10 and later is supported.
</p>
<p style="margin-bottom:0">
Path to the include headers of the required Perl version must be specified
in the <code>PERL_INCLUDE</code> variable using
</p>
<pre style="margin-top:0">
make PERL_INCLUDE=path_to_Perl_includes
</pre>

<a id="python_installation" name="python_installation"></a>
<h3>4.3.4. Python</h3>

<p>
The Python bindings are available as <code>ufal.nametag</code> package on PyPI.
</p>
<p>
To compile Python bindings manually, run <code>make</code> in the <code>bindings/python</code>
directory, optionally with options described in NameTag Installation. Both
Python 2.6+ and Python 3+ are supported.
</p>
<p style="margin-bottom:0">
Path to the include headers of the required Python version must be specified
in the <code>PYTHON_INCLUDE</code> variable using
</p>
<pre style="margin-top:0">
make PYTHON_INCLUDE=path_to_Python_includes
</pre>

<a id="users_manual" name="users_manual"></a>
<h1>5. NameTag User's Manual</h1>

<p>
In a natural language text, the task of named entity recognition (NER) is to
identify proper names such as names of persons, organizations and locations.
NameTag recognizes named entities in an unprocessed text using
<a href="http://ufal.mff.cuni.cz/morphodita">MorphoDiTa</a>.
MorphoDiTa library tokenizes the text and performs morphological analysis and tagging
and NameTag identifies and classifies named entities by an algorithm described in
<a href="http://ufal.mff.cuni.cz/~straka/papers/2013-tsd_ner.pdf">Straková et al. 2013</a>.
NameTag can also performs NER in custom tokenized and morphologically analyzed and
tagged texts.
</p>
<p>
Like any supervised machine learning tool, NameTag needs a trained linguistic
model.  This section describes the available language models and also the
commandline tools. The C++ library is described in NameTag API Reference.
</p>

<a id="czech-cnec" name="czech-cnec"></a>
<h2>5.1. Czech NameTag Models</h2>

<p>
Czech models are distributed under the
<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA</a> licence.
They are trained on <a href="http://ufal.mff.cuni.cz/cnec/">Czech Named Entity Corpus</a>
1.1 and 2.0 and internally use <a href="http://ufal.mff.cuni.cz/morphodita/">MorphoDiTa</a>
as a tagger and lemmatizer. Czech models work in NameTag version 1.0 or later.
</p>
<p>
Czech models are versioned according to the date when released, the version
format is <code>YYMMDD</code>, where <code>YY</code>, <code>MM</code> and <code>DD</code> are two-digit
representation of year, month and day, respectively. The latest version is
140304.
</p>

<a id="czech-cnec_download" name="czech-cnec_download"></a>
<h3>5.1.1. Download</h3>

<p>
The latest version 140304 of the Czech NameTag models can be downloaded
from <a href="http://hdl.handle.net/11858/00-097C-0000-0023-7D42-8">LINDAT/CLARIN repository</a>.
</p>

<a id="czech-cnec_acknowledgements" name="czech-cnec_acknowledgements"></a>
<h3>5.1.2. Acknowledgements</h3>

<p>
This work has been using language resources developed and/or stored and/or
distributed by the LINDAT/CLARIN project of the Ministry of Education of the
Czech Republic (project <i>LM2010013</i>).
</p>
<p>
Czech models are trained on Czech Named Entity Corpus, which was created by
Magda Ševčíková, Zdeněk Žabokrtský, Jana Straková and Milan Straka.
</p>
<p>
The recognizer research was supported by the projects
<i>MSM0021620838</i> and <i>LC536</i> of Ministry of Education, Youth and Sports of the Czech Republic,
<i>1ET101120503</i> of Academy of Sciences of the Czech Republic, LINDAT/CLARIN
project of the Ministry of Education of the Czech Republic (project <i>LM2010013</i>),
and partially by SVV project number 267 314.  The research was performed by
Jana Straková, Zdeněk Žabokrtský and Milan Straka.
</p>
<p>
Czech models use MorphoDiTa as a tagger and lemmatizer, therefore
<a href="http://ufal.mff.cuni.cz/morphodita#morphodita_acknowledgements">MorphoDiTa Acknowledgements</a>
and
<a href="http://ufal.mff.cuni.cz/morphodita/users-manual#czech-morfflex-pdt_acknowledgements">Czech MorphoDiTa Model Acknowledgements</a>
apply.
</p>

<a id="czech-cnec_publications" name="czech-cnec_publications"></a>
<h4>5.1.2.1. Publications</h4>

<ul>
<li>Ševčíková Magda, Žabokrtský Zdeněk, Krůza Ondřej: <i><a href="http://ufal.mff.cuni.cz/~zabokrtsky/publications/papers/tsd07-namedent.pdf">Named Entities in Czech: Annotating Data and Developing NE Tagger</a>.</i> In: Matoušek, V., Mautner, P. (eds.) TSD 2007. LNCS (LNAI), vol. 4629, pp. 188–195. Springer, Heidelberg (2007).
<p></p>
</li>
<li>Kravalová Jana, Žabokrtský Zdeněk: <i><a href="http://aclweb.org/anthology//W/W09/W09-3538.pdf">Czech Named Entity Corpus and SVM-based Recognizer</a>.</i> In: Proceedings of the 2009 Named Entities Workshop: Shared Task on Transliteration. NEWS 2009, pp. 194–201. Association for Computational Linguistics (2009).
<p></p>
</li>
<li>Straková Jana, Straka Milan, Hajič Jan: <i><a href="http://ufal.mff.cuni.cz/~straka/papers/2013-tsd_ner.pdf">A New State-of-The-Art Czech Named Entity Recognizer</a>.</i> In: Lecture Notes in Computer Science, Vol. 8082, Text, Speech and Dialogue: 16th International Conference, TSD 2013. Proceedings, Copyright © Springer Verlag, Berlin / Heidelberg, ISBN 978-3-642-40584-6, ISSN 0302-9743, pp. 68-75, 2013
<p></p>
</li>
<li>Straková Jana, Straka Milan and Hajič Jan. <i><a href="http://www.aclweb.org/anthology/P/P14/P14-5003.pdf">Open-Source Tools for Morphology, Lemmatization, POS Tagging and Named Entity Recognition.</a></i> In Proceedings of 52nd Annual Meeting of the Association for Computational Linguistics: System Demonstrations, pages 13-18, Baltimore, Maryland, June 2014. Association for Computational Linguistics.
</li>
</ul>

<a id="czech-cnec20_model" name="czech-cnec20_model"></a>
<h3>5.1.3. Czech Named Entity Corpus 2.0 Model</h3>

<p>
The model is trained on the training portion of the
<a href="http://ufal.mff.cuni.cz/cnec/cnec2.0">Czech Named Entity Corpus 2.0</a>.
The corpus uses a
<a href="http://ufal.mff.cuni.cz/~strakova/cnec2.0/ne-type-hierarchy.pdf">detailed two-level named entity hierarchy</a>,
whose detailed description is available in the documentation of the
<a href="http://ufal.mff.cuni.cz/cnec/cnec2.0">Czech Named Entity Corpus 2.0</a>.
This hierarchy is an updated version of CNEC
1.1 hierarchy and is more suitable for automatic named entity recognition.
</p>

<dl>
<dt><code>czech-cnec2.0-&lt;version&gt;.ner</code></dt><dd>
  Czech named entity recognizer trained on training portion of <a href="http://ufal.mff.cuni.cz/cnec/cnec2.0">CNEC 2.0</a>.
<p></p>
  The latest version <code>czech-cnec2.0-140304.ner</code> reaches 75.38% F1-measure
  on two-level hierarchy and 79.16% F1-measure on top-level hierarchy of
  <a href="http://ufal.mff.cuni.cz/cnec/cnec2.0">CNEC 2.0</a> etest data.  Model speed:
  ~40k words/s, model size: ~8MB.
<p></p>
</dd>
<dt><code>czech-cnec2.0-&lt;version&gt;-no_numbers.ner</code></dt><dd>
  Czech named entity recognizer trained on training portion of <a href="http://ufal.mff.cuni.cz/cnec/cnec2.0">CNEC 2.0</a>,
  except for the supertype <code>n</code> (Number expressions), which is not included.
<p></p>
  The latest version <code>czech-cnec2.0-140304-no_numbers.ner</code> reaches 77.35%
  F1-measure on two-level hierarchy and 80.59% F1-measure on top-level
  hierarchy of <a href="http://ufal.mff.cuni.cz/cnec/cnec2.0">CNEC 2.0</a> etest data
  without <code>n</code> (Number expressions) supertype.  Model speed: ~45k words/s,
  model size: ~8MB.
</dd>
</dl>

<a id="czech-cnec11_model" name="czech-cnec11_model"></a>
<h3>5.1.4. Czech Named Entity Corpus 1.1 Model</h3>

<p>
The model is trained on the training portion of the
<a href="http://ufal.mff.cuni.cz/cnec/cnec1.1">Czech Named Entity Corpus 1.1</a>.
The corpus uses a
<a href="http://ufal.mff.cuni.cz/~strakova/cnec1.0/ne-type-hierarchy.pdf">detailed two-level named entity hierarchy</a>,
whose detailed description is available in the documentation of the
<a href="http://ufal.mff.cuni.cz/cnec/cnec1.1">Czech Named Entity Corpus 1.1</a>.
</p>

<dl>
<dt><code>czech-cnec1.1-&lt;version&gt;.ner</code></dt><dd>
  Czech named entity recognizer trained on training portion of <a href="http://ufal.mff.cuni.cz/cnec/cnec1.1">CNEC 1.1</a>.
<p></p>
  The latest version <code>czech-cnec1.1-140304.ner</code> reaches 75.47% F1-measure on
  two-level hierarchy and 78.51% F1-measure on top-level hierarchy of
  <a href="http://ufal.mff.cuni.cz/cnec/cnec1.1">CNEC 1.1</a> etest data.  Model speed:
  ~35k words/s, model size: ~7MB.
<p></p>
</dd>
<dt><code>czech-cnec1.1-&lt;version&gt;-no_numbers.ner</code></dt><dd>
  Czech named entity recognizer trained on training portion of <a href="http://ufal.mff.cuni.cz/cnec/cnec1.1">CNEC 1.1</a>,
  except for the supertypes <code>c</code> (Bibliographic items), <code>n</code> (Number expressions) and
  <code>q</code> (Quantitative expressions), which are not included.
<p></p>
  The latest version <code>czech-cnec1.1-140304-no_numbers.ner</code> reaches 77.48%
  F1-measure on two-level hierarchy and 80.72% F1-measure on top-level
  hierarchy of <a href="http://ufal.mff.cuni.cz/cnec/cnec1.1">CNEC 1.1</a> etest data
  without <code>c</code> (Bibliographic items), <code>n</code> (Number expressions) and <code>q</code>
  (Quantitative expressions) supertypes.  Model speed: ~40k words/s,
  model size: ~7MB.
</dd>
</dl>

<a id="english-conll" name="english-conll"></a>
<h2>5.2. English NameTag Models</h2>

<p>
English models are distributed under the
<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA</a> licence. They
are trained on
<a href="https://www.aclweb.org/anthology/W03-0419/">CoNLL-2003 NER annotations (Sang and De Meulder, 2003)</a>
of part of <a href="http://trec.nist.gov/data/reuters/reuters.html">Reuters Corpus</a> and internally use [MorphoDiTa
<a href="http://ufal.mff.cuni.cz/morphodita/">http://ufal.mff.cuni.cz/morphodita/</a>] as a tagger and lemmatizer. English models
work in NameTag version 1.0 or later.
</p>
<p>
English models are versioned according to the date when released, the version
format is <code>YYMMDD</code>, where <code>YY</code>, <code>MM</code> and <code>DD</code> are two-digit
representation of year, month and day, respectively. The latest version is
140408.
</p>

<a id="english-conll_acknowledgements" name="english-conll_acknowledgements"></a>
<h3>5.2.1. Acknowledgements</h3>

<p>
This work has been using language resources developed and/or stored and/or
distributed by the LINDAT/CLARIN project of the Ministry of Education of the
Czech Republic (project <i>LM2010013</i>).
</p>
<p>
The recognizer research was supported by the projects
<i>MSM0021620838</i> and <i>LC536</i> of Ministry of Education, Youth and Sports of the Czech Republic,
<i>1ET101120503</i> of Academy of Sciences of the Czech Republic, LINDAT/CLARIN
project of the Ministry of Education of the Czech Republic (project <i>LM2010013</i>),
and partially by SVV project number 267 314.  The research was performed by
Jana Straková, Zdeněk Žabokrtský and Milan Straka.
</p>
<p>
Czech models use MorphoDiTa as a tagger and lemmatizer, therefore
<a href="http://ufal.mff.cuni.cz/morphodita#morphodita_acknowledgements">MorphoDiTa Acknowledgements</a>
and
<a href="http://ufal.mff.cuni.cz/morphodita/users-manual#english-morphium-wsj_acknowledgements">English MorphoDiTa Model Acknowledgements</a>
apply.
</p>

<a id="english-conll_publications" name="english-conll_publications"></a>
<h4>5.2.1.1. Publications</h4>

<ul>
<li>Straková Jana, Straka Milan, Hajič Jan: <i><a href="http://ufal.mff.cuni.cz/~straka/papers/2013-tsd_ner.pdf">A New State-of-The-Art Czech Named Entity Recognizer</a>.</i> In: Lecture Notes in Computer Science, Vol. 8082, Text, Speech and Dialogue: 16th International Conference, TSD 2013. Proceedings, Copyright © Springer Verlag, Berlin / Heidelberg, ISBN 978-3-642-40584-6, ISSN 0302-9743, pp. 68-75, 2013
<p></p>
</li>
<li>Straková Jana, Straka Milan and Hajič Jan. <i><a href="http://www.aclweb.org/anthology/P/P14/P14-5003.pdf">Open-Source Tools for Morphology, Lemmatization, POS Tagging and Named Entity Recognition.</a></i> In Proceedings of 52nd Annual Meeting of the Association for Computational Linguistics: System Demonstrations, pages 13-18, Baltimore, Maryland, June 2014. Association for Computational Linguistics.
</li>
</ul>

<a id="english-conll_model" name="english-conll_model"></a>
<h3>5.2.2. English Model</h3>

<p>
English model is trained on <a href="https://www.aclweb.org/anthology/W03-0419/">CoNLL-2003 NER annotations (Sang and De Meulder, 2003)</a> of part of
<a href="http://trec.nist.gov/data/reuters/reuters.html">Reuters Corpus</a>. The corpus uses coarse
classification using four classes <code>PER</code>, <code>ORG</code>, <code>LOC</code> and <code>MISC</code>.
</p>
<p>
The latest version 140408 of the English-CoNLL NameTag models can be downloaded from
<a href="http://hdl.handle.net/11234/1-3118">LINDAT/CLARIN repository</a>.
</p>
<p>
The model <code>english-conll-140408.ner</code> reaches 84.73% F1-measure on
CoNLL2003 etest data. Model speed: ~20k words/s, model size: ~10MB.
</p>

<a id="run_ner" name="run_ner"></a>
<h2>5.3. Running the Recognizer</h2>

<p style="margin-bottom:0">
The NameTag Recognizer can be executed using the following command:
</p>
<pre style="margin-top:0">
run_ner recognizer_model
</pre>

<p>
The input is assumed to be in UTF-8 encoding and can be either already
tokenized and segmented, or it can be a plain text which is tokenized and
segmented automatically.
</p>
<p>
Any number of files can be specified after the <code>recognizer_model</code>. If an
argument <code>input_file:output_file</code> is used, the given <code>input_file</code> is
processed and the result is saved to <code>output_file</code>. If only <code>input_file</code> is
used, the result is saved to standard output. If no argument is given, input is
read from standard input and written to standard output.
</p>
<p style="margin-bottom:0">
The full command syntax of <code>run_ner</code> is
</p>
<pre style="margin-top:0">
Usage: run_ner [options] recognizer_model [file[:output_file]]...
Options: --input=untokenized|vertical
         --output=conll|vertical|xml
</pre>

<a id="run_ner_input_formats" name="run_ner_input_formats"></a>
<h3>5.3.1. Input Formats</h3>

<p style="margin-bottom:0">
The input format is specified using the <code>--input</code> option. Currently supported
input formats are:
</p>
<ul style="margin-top:0">
<li><code>untokenized</code> (default): the input is tokenized and segmented using
  a tokenizer defined by the model,
</li>
<li><code>vertical</code>: the input is in vertical format, every line is considered
  a word, with empty line denoting end of sentence.
</li>
</ul>

<a id="run_ner_output_formats" name="run_ner_output_formats"></a>
<h3>5.3.2. Output Formats</h3>

<p style="margin-bottom:0">
The output format is specified using the <code>--output</code> option. Currently
supported output formats are:
</p>
<ul style="margin-top:0">
<li><code>xml</code> (default): Simple XML format without a root element, using
  <code>&lt;sentence&gt;</code> element to mark sentences and
  <code>&lt;token&gt;</code> element to mark tokens. The recognized named entities
  are encoded using <code>&lt;ne type="..."&gt;</code> element.
<p></p>
  Example input:

<pre>
Václav Havel byl český dramatik, esejista, kritik komunistického režimu a později politik.
</pre>

<p></p>
  A NameTag identifies a first name (<code>pf</code>), a surname (<code>ps</code>) and a person name container (<code>P</code>) in the input (line breaks added):

<pre>
  &lt;sentence&gt;&lt;ne type="P"&gt;&lt;ne type="pf"&gt;&lt;token&gt;Václav&lt;/token&gt;&lt;/ne&gt; &lt;ne type="ps"&gt;&lt;token&gt;Havel&lt;/token&gt;&lt;/ne&gt;&lt;/ne&gt;
  &lt;token&gt;byl&lt;/token&gt; &lt;token&gt;český&lt;/token&gt; &lt;token&gt;dramatik&lt;/token&gt;&lt;token&gt;,&lt;/token&gt; &lt;token&gt;esejista&lt;/token&gt;&lt;token&gt;,&lt;/token&gt;
  &lt;token&gt;kritik&lt;/token&gt; &lt;token&gt;komunistického&lt;/token&gt; &lt;token&gt;režimu&lt;/token&gt; &lt;token&gt;a&lt;/token&gt; &lt;token&gt;později&lt;/token&gt;
  &lt;token&gt;politik&lt;/token&gt;&lt;token&gt;.&lt;/token&gt;&lt;/sentence&gt;
</pre>

<p></p>
</li>
<li><code>vertical</code>: Every found named entity is on a separate line. Each line
  contains three tab-separated fields: <i>entity_range</i>, <i>entity_type</i>
  and <i>entity_text</i>. The <i>entity_range</i> is composed of token identifiers
  (counting from 1 and including end-of-sentence; if the input is also <code>vertical</code>,
  token identifiers correspond exactly to line numbers) of tokens forming the
  named entity and <i>entity_type</i> represents its type. The <i>entity_text</i> is
  not strictly necessary and contains space separated words of this named
  entity.
<p></p>
  Example input:

<pre>
Václav Havel byl český dramatik, esejista, kritik komunistického režimu a později politik.
</pre>

<p></p>
  Example output:

<pre>
1,2	P	Václav Havel
1	pf	Václav
2	ps	Havel
</pre>

<p></p>
</li>
<li><code>conll</code>: A CoNLL-like vertical format. Every word is on a line, followed by a tab and
  recognized entity label. An empty line denotes end of sentence. The entity labels are:
  <ul>
  <li><code>O</code>: no entity
  </li>
  <li><code>B-type</code>: the word is the first in the entity of type <code>type</code>
  </li>
  <li><code>I-type</code>: the word is a non-initial word in the entity of type <code>type</code>
  </li>
  </ul>
  If there are embedded entities, only the outermost entity is saved in the
  file, the embedded ones are ignored.
<p></p>
  Example input:

<pre>
Václav Havel byl český dramatik, esejista, kritik komunistického režimu a později politik.
</pre>

<p></p>
  Example output:

<pre>
Václav	B-P
Havel	I-P
byl	O
český	O
...
</pre>

</li>
</ul>

<a id="run_tokenizer" name="run_tokenizer"></a>
<h2>5.4. Running the Tokenizer</h2>

<p>
Using the <code>run_tokenizer</code> executable it is possible to perform only
tokenization and segmentation used in a specified model.
</p>
<p>
The input is a UTF-8 encoded plain text and the input files are specified same
as with the <a href="#run_ner"><code>run_ner</code></a> command.
</p>
<p style="margin-bottom:0">
The full command syntax of <code>run_tokenizer</code> is
</p>
<pre style="margin-top:0">
run_tokenizer [options] recognizer_model [file[:output_file]]...
Options: --output=vertical|xml
</pre>

<a id="run_tokenizer_output_formats" name="run_tokenizer_output_formats"></a>
<h3>5.4.1. Output Formats</h3>

<p style="margin-bottom:0">
The output format is specified using the <code>--output</code> option. Currently
supported output formats are:
</p>
<ul style="margin-top:0">
<li><code>xml</code> (default): Simple XML format without a root element, using
  <code>&lt;sentence&gt;</code> element to mark sentences and <code>&lt;token&gt;</code> element to mark
  tokens.
<p></p>
  Example output for input <code>Děti pojedou k babičce. Už se těší.</code> (line breaks added):

<pre>
&lt;sentence&gt;&lt;token&gt;Děti&lt;/token&gt; &lt;token&gt;pojedou&lt;/token&gt; &lt;token&gt;k&lt;/token&gt;
&lt;token&gt;babičce&lt;/token&gt;&lt;token&gt;.&lt;/token&gt;&lt;/sentence&gt; &lt;sentence&gt;&lt;token&gt;Už&lt;/token&gt;
&lt;token&gt;se&lt;/token&gt; &lt;token&gt;těší&lt;/token&gt;&lt;token&gt;.&lt;/token&gt;&lt;/sentence&gt;
</pre>

<p></p>
</li>
<li><code>vertical</code>: Each token is on a separate line, every sentence is ended by
  a blank line.
<p></p>
  Example output for input <code>Děti pojedou k babičce. Už se těší.</code>:

<pre>
Děti
pojedou
k
babičce
.

Už
se
těší
.

</pre>

</li>
</ul>

<a id="rest_server" name="rest_server"></a>
<h2>5.5. Running REST Server</h2>

<p>
NameTag also provides REST server binary <code>nametag_server</code>.
The binary uses <a href="http://github.com/ufal/microrestd">MicroRestD</a> as a REST
server implementation and provides
<a href="http://lindat.mff.cuni.cz/services/nametag/api-reference.php">NameTag REST API</a>.
</p>
<p style="margin-bottom:0">
The full command syntax of <code>nametag_server</code> is
</p>
<pre style="margin-top:0">
nametag_server [options] port (model_name model_file acknowledgements)*
Options: --connection_timeout=maximum connection timeout [s] (default 60)
         --daemon (daemonize after start, supported on Linux only)
         --log_file=file path (no logging if empty, default nametag_server.log)
         --log_request_max_size=max req log size [kB] (0 unlimited, default 64)
         --max_connections=maximum network connections (default 256)
         --max_request_size=maximum request size [kB] (default 1024)
         --threads=threads to use (default 0 means unlimitted)
</pre>

<p>
The <code>nametag_server</code> can run either in foreground or in background (when
<code>--daemon</code> is used). The specified model files are loaded during start and
kept in memory all the time. This behaviour might change in future to load the
models on demand.
</p>

<a id="custom_models" name="custom_models"></a>
<h2>5.6. Training of Custom Models</h2>

<p>
Training of custom models is possible using the <code>train_ner</code> binary.
</p>

<a id="training_data" name="training_data"></a>
<h3>5.6.1. Training data</h3>

<p>
To train a named entity recognizer model, training data is needed. The training
data must be tokenized and contain annotated name entities. The name entities
are non-overlapping, consist of a sequence of words and have a specified type.
</p>
<p style="margin-bottom:0">
The training data must be encoded in UTF-8 encoding. The lines correspond to
individual words and an empty line denotes an end of sentence. Each non-empty
line contains exactly two tab-separated columns, the first is the word form and the
second is the annotation. The format of the annotation is taken from CoNLL-2003:
the annotation <code>O</code> (or <code>_</code>) denotes no named entity,
annotations <code>I-type</code> and <code>B-type</code> denote named entity of specified type.
The <code>I-type</code> and <code>B-type</code> annotations are equivalent
except for one case &ndash; if the previous word is also a named entity of same type, then
</p>
 <ul style="margin-top:0">
 <li>if the current word is annotated as <code>I-type</code>, it is part of the same named
   entity as the previous word,
 </li>
 <li>if the current word is annotated as <code>B-type</code>, it is in a different name entity
   than the previous word (albeit with the same type).
 </li>
 </ul>

<a id="tagger" name="tagger"></a>
<h3>5.6.2. Tagger</h3>

<p>
Most named entity recognizer models utilize part of speech tags and lemmas.
NameTag can utilize several taggers to obtain the tags and lemmas:
</p>

<dl>
<dt><code>trivial</code></dt><dd>
  Do not use any tagger. The lemma is the same as the given form and there is
  no part of speech tag.
<p></p>
</dd>
<dt><code>external</code></dt><dd>
  Use some external tagger. The input "forms" can contain multiple space-separated values,
  first being the <i>form</i>, second the <i>lemma</i> and the rest is <i>part of speech tag</i>.
  The part of speech tag is optional. The lemma is also optional and if missing, the form
  itself is used as a lemma.
<p></p>
</dd>
<dt><code>morphodita:model</code></dt><dd>
  Use <a href="http://ufal.mff.cuni.cz/morphodita">MorphoDiTa</a> as a tagger with the
  specified model. This tagger model is embedded in resulting named entity recognizer model.
  The <i>lemmatizer</i> model of MorphoDiTa is recommended, because it is very fast, small
  and detailed part of speech tags do not improve the performance of the named entity recognizer
  significantly.
</dd>
</dl>

<a id="tagger_lemma_structure" name="tagger_lemma_structure"></a>
<h4>5.6.2.1. Lemma Structure</h4>

<p style="margin-bottom:0">
The lemmas used by the recognizer can be structured and consist of three parts:
</p>
<ul style="margin-top:0">
<li><i>raw lemma</i> is the textual form of the lemma, possibly ambiguous
</li>
<li><i>lemma id</i> is the unique lemma identification (for example a raw lemma plus
  a numeric identifier)
</li>
<li><i>lemma comment</i> is additional information about a lemma occurrence, not used
  to identify the lemma. If used, it usually contains information which is not
  possible to encode in part of speech tags.
</li>
</ul>

<p>
Currently, all these parts are filled only when <code>morphodita</code> tagger is used.
If <code>external</code> tagger is used, raw lemma and lemma id are the same and lemma
comment is empty.
</p>

<a id="feature_templates" name="feature_templates"></a>
<h3>5.6.3. Feature Templates</h3>

<p>
The recognizer utilizes feature templates to generate features which are used
as the input to the named entity classifier. The feature templates are
specified in a file, one feature template on a line. Empty lines and lines
starting with <code>#</code> are ignored.
</p>
<p>
The first space-separated column on a line is the name of the feature template,
optionally followed by a slash and a window size. The window size specifies how
many adjacent words can observe the feature template value of a given word,
with default value of 0 denoting only the word in question.
</p>
<p style="margin-bottom:0">
List of commonly used feature templates follows. Note that it is probably not
exhaustive (see the sources in the <code>features</code> directory).
</p>
<ul style="margin-top:0">
<li><code>BrownClusters file [prefix_lengths]</code> &ndash; use Brown clusters found in the
  specified file. An optional list of lengths of cluster prefixes to be used
  in addition to the full Brown cluster can be specified. Each line of the Brown
  clusters file must contain two tab-separated columns, the first of which is
  the Brown cluster label and the second is a raw lemma.
</li>
<li><code>CzechAddContainers</code> &ndash; add CNEC containers (currently only <code>P</code> and <code>T</code>)
</li>
<li><code>CzechLemmaTerm</code> &ndash; feature template specific for Czech morphological system
  by Jan Hajič (<a href="http://books.google.cz/books?id=sB63AAAACAAJ">Hajič 2004</a>).
  The term information (personal name, geographic name, ...) specified in lemma
  comment are used as features.
</li>
<li><code>Form</code> &ndash; use forms as features
</li>
<li><code>FormCapitalization</code> &ndash; use capitalization of form as features
</li>
<li><code>FormCaseNormalized</code> &ndash; use case normalized (first character as-is, others
  lowercased) forms as features
</li>
<li><code>FormCaseNormalizedSuffix shortest longest</code> &ndash; use suffixes of case
  normalized (first character as-is, others lowercased) forms of lengths
  between <code>shortest</code> and <code>longest</code>
</li>
<li><code>Gazetteers [files]</code> &ndash; use given files as gazetteers. Each file is one
  gazetteers list independent of the others and must contain a set of lemma
  sequences, each on a line, represented as raw lemmas separated by spaces.
</li>
<li><code>GazetteersEnhanced (form|rawlemma|rawlemmas) (embed_in_model|out_of_model) file_base entity [file_base entity ...]</code>
  &ndash; use gazetteers from given files. Each gazetteer contains (possibly multiword)
  named entities per line. Matching of the named entities can be performed either
  using <code>form</code>, disambiguated <code>rawlemma</code> of any of <code>rawlemma</code>s proposed
  by the morphological analyzer. The gazetteers might be embedded in the model
  file or not; in either case, additional gazetteers are loaded during each
  startup. For each <code>file_base</code> specified in <code>GazetteersEnhanced</code> templates,
  three files are tried:
  <ul>
  <li><code>file_base.txt</code>: gazetteers used as features, representing each
    <code>file_base</code> with a unique feature
  </li>
  <li><code>file_base.hard_pre.txt</code>: matched named entities (finding non-overlapping
    entities, preferring the ones starting earlier and longer ones in case of
    ties) are forced to the specified <code>entity</code> type even <i>before</i> the
    NER model is executed
  </li>
  <li><code>file_base.hard_post.txt</code>: <i>after</i> running the NER model, tokens not
    recognized as entities are matched against the gazetteers (again finding
    non-overlapping entities, preferring the ones starting earlier and longer
    ones in case of ties) and marked as <code>entity</code> type if found
  </li>
  </ul>
</li>
<li><code>Lemma</code> &ndash; use lemma ids as a feature
</li>
<li><code>NumericTimeValue</code> &ndash; recognize numbers which could represent hours,
  minutes, hour:minute time, days, months or years
</li>
<li><code>PreviousStage</code> &ndash; use named entities predicted by previous stage as features
</li>
<li><code>RawLemma</code> &ndash; use raw lemmas as features
</li>
<li><code>RawLemmaCapitalization</code> &ndash; use capitalization of raw lemma as features
</li>
<li><code>RawLemmaCaseNormalized</code> &ndash; use case normalized (first character as-is, others
  lowercased) raw lemmas as features
</li>
<li><code>RawLemmaCaseNormalizedSuffix shortest longest</code> &ndash; use suffixes of case
  normalized (first character as-is, others lowercased) raw lemmas of lengths
  between <code>shortest</code> and <code>longest</code>
</li>
<li><code>Tag</code> &ndash; use tags as features
</li>
<li><code>URLEmailDetector url_type email_type</code> &ndash; detect URLs and emails. If an URL
  or an email is detected, it is immediately marked with specified named entity
  type and not used in further processing.
</li>
</ul>

<p style="margin-bottom:0">
For inspiration, we present feature file used for Czech NER model. This feature
file is a simplified version of feature templates described in the paper
Straková et al. 2013: Straková Jana, Straka Milan, Hajič Jan, <i><a href="http://ufal.mff.cuni.cz/~straka/papers/2013-tsd_ner.pdf">A New State-of-The-Art Czech Named Entity Recognizer.</a></i> In: Lecture Notes in Computer Science, Vol. 8082, Text, Speech and Dialogue: 16th International Conference, TSD 2013. Proceedings, Copyright © Springer Verlag, Berlin / Heidelberg, ISBN 978-3-642-40584-6, ISSN 0302-9743, pp. 68-75, 2013.
</p>
<pre style="margin-top:0">
# Sentence processors
Form/2
Lemma/2
RawLemma/2
RawLemmaCapitalization/2
Tag/2
NumericTimeValue/1

CzechLemmaTerm/2

BrownClusters/2 clusters/wiki-1000-3

Gazetteers/2 gazetteers/cities.txt gazetteers/clubs.txt gazetteers/countries.txt gazetteers/feasts.txt gazetteers/institutions.txt gazetteers/months.txt gazetteers/objects.txt gazetteers/psc.txt gazetteers/streets.txt

PreviousStage/5

# Detectors
URLEmailDetector mi me

# Entity processors
CzechAddContainers
</pre>

<a id="train_ner" name="train_ner"></a>
<h3>5.6.4. Running train_ner</h3>

<p>
The <code>train_ner</code> binary has the following arguments (which has to be specified
in this order):
</p>

<ol>
<li><i>ner_identifier</i> &ndash; identifier of the named entity recognizer type. This affects
  the tokenizer used in this model, and in theory any other aspect of the recognizer.
  Supported values:
   <ul>
   <li><i>czech</i>
   </li>
   <li><i>english</i>
   </li>
   <li><i>generic</i>
   <p></p>
   </li>
   </ul>
</li>
<li><i>tagger</i> &ndash; the tagger identifier as described in the <a href="#tagger">Tagger</a> section
<p></p>
</li>
<li><i>feature_templates_file</i> &ndash; file with feature templates as described in the
  <a href="#feature_templates">Feature Templates</a> section.
<p></p>
</li>
<li><i>stages</i> &ndash; the number of stages performed during recognition. Common
  values are either <i>1</i> or <i>2</i>. With more stages, the model is larger and
  recognition is slower, but more accurate.
<p></p>
</li>
<li><i>iterations</i> &ndash; the number of iterations performed when training each stage
  of the recognizer. With more iterations, training take longer (the
  recognition time is unaffected), but the model gets over-trained when too
  many iterations are used. Values from <i>10</i> to <i>30</i> or <i>50</i> are commonly used.
<p></p>
</li>
<li><i>missing_weight</i> &ndash; default value of missing weights in the log-linear model.
  Common values are small negative real numbers like <i>-0.2</i>.
<p></p>
</li>
<li><i>initial_learning_rage</i> &ndash; learning rate used in the first iteration of SGD
  training method of the log-linear model. Common value is <i>0.1</i>.
<p></p>
</li>
<li><i>final_learning_rage</i> &ndash; learning rate used in the last iteration of SGD
  training method of the log-linear model. Common values are in range from
  <i>0.1</i> to <i>0.001</i>, with <i>0.01</i> working reasonably well.
<p></p>
</li>
<li><i>gaussian</i> &ndash; the value of Gaussian prior imposed on the weights. In other
  words, value of L2-norm regularizer. Common value is either <i>0</i> for no regularization,
  or small real number like <i>0.5</i>.
<p></p>
</li>
<li><i>hidden_layer</i> &ndash; experimental support for hidden layer in the artificial
  neural network classifier. To not use the hidden layer (recommended), use <i>0</i>.
  Otherwise, specify the number of neurons in the hidden layer. Please note that
  non-zero values will create enormous models, slower recognition and are
  <i>not</i> guaranteed to create models with better accuracy.
<p></p>
</li>
<li><i>heldout_data</i> &ndash; optional parameter with heldout data in the
  <a href="#training_data">described</a> format. If the heldout data is present, the
  accuracy of the heldout data classification is printed during training. The
  heldout data is not used in any other way.
</li>
</ol>

<p>
The training data in the <a href="#training_data">described</a> format is read from the standard
input and the trained model is written to the standard output if the training
is successful.
</p>

<a id="api_reference" name="api_reference"></a>
<h1>6. NameTag API Reference</h1>

<p>
The NameTag API is defined in header <code>nametag.h</code> and resides in
<code>ufal::nametag</code> namespace.
</p>
<p>
The strings used in the NameTag API are always UTF-8 encoded (except from
file paths, whose encoding is system dependent).
</p>

<a id="versioning" name="versioning"></a>
<h2>6.1. NameTag Versioning</h2>

<p>
NameTag is versioned using <a href="http://semver.org/">Semantic Versioning</a>.
Therefore, a version consists of three numbers <i>major.minor.patch</i>, optionally
followed by a hyphen and pre-release version info, with the following semantics:
</p>

<ul>
<li>Stable versions have no pre-release version info, development have non-empty
  pre-release version info.
</li>
<li>Two versions with the same <i>major.minor</i> have the same API with the same
  behaviour, apart from bugs. Therefore, if only <i>patch</i> is increased, the
  new version is only a bug-fix release.
</li>
<li>If two versions <i>v</i> and <i>u</i> have the same <i>major</i>, but <i>minor(v)</i> is
  greater than <i>minor(u)</i>, version <i>v</i> contains only additions to the API.
  In other words, the API of <i>u</i> is all present in <i>v</i> with the same
  behaviour (once again apart from bugs). It is therefore safe to upgrade to
  a newer NameTag version with the same <i>major</i>.
</li>
<li>If two versions differ in <i>major</i>, their API may differ in any way.
</li>
</ul>

<p>
Models created by NameTag have the same behaviour in all NameTag
versions with same <i>major</i>, apart from obvious bugfixes. On the other hand,
models created from the same data by different <i>major.minor</i> NameTag
versions may have different behaviour.
</p>

<a id="string_piece" name="string_piece"></a>
<h2>6.2. Struct string_piece</h2>

<pre>
struct string_piece {
  const char* str;
  size_t len;

  string_piece();
  string_piece(const char* str);
  string_piece(const char* str, size_t len);
  string_piece(const std::string&amp; str);
}
</pre>

<p>
The <a href="#string_piece"><code>string_piece</code></a> is used for efficient string passing. The string
referenced in <a href="#string_piece"><code>string_piece</code></a> is not owned by it, so users have to make sure
the referenced string exists as long as the <a href="#string_piece"><code>string_piece</code></a>.
</p>

<a id="token_range" name="token_range"></a>
<h2>6.3. Struct token_range</h2>

<pre>
struct token_range {
  size_t start;
  size_t length;
};
</pre>

<p>
The <a href="#token_range"><code>token_range</code></a> represent a range of a token as returned by a <a href="#tokenizer">tokenizer</a>.
The <code>start</code> and <code>length</code> fields specify the token position in Unicode
characters, not in bytes of UTF-8 encoding.
</p>

<a id="named_entity" name="named_entity"></a>
<h2>6.4. Struct named_entity</h2>

<pre>
struct named_entity {
  size_t start;
  size_t length;
  std::string type;

  named_entity();
  named_entity(size_t start, size_t length, const std::string&amp; type);
};
</pre>

<p>
The <a href="#named_entity"><code>named_entity</code></a> is used to represend a named entity. The
<code>start</code> and <code>length</code> fields represent the entity range in either tokens,
unicode characters or bytes, depending on the usage. The <code>type</code> represents
the entity type.
</p>

<a id="version" name="version"></a>
<h2>6.5. Class version</h2>

<pre>
class version {
 public:
  unsigned major;
  unsigned minor;
  unsigned patch;

  static <A HREF="#version">version</A> <A HREF="#version_current">current</A>();
};
</pre>

<p>
The <a href="#version"><code>version</code></a> class represents NameTag version.
See <a href="#versioning">NameTag Versioning</a> for more information.
</p>

<a id="version_current" name="version_current"></a>
<h3>6.5.1. version::current</h3>

<pre>
static <A HREF="#version">version</A> current();
</pre>

<p>
Returns current NameTag version.
</p>

<a id="tokenizer" name="tokenizer"></a>
<h2>6.6. Class tokenizer</h2>

<pre>
class tokenizer {
 public:
  virtual ~tokenizer() {}

  virtual void <A HREF="#tokenizer_set_text">set_text</A>(<A HREF="#string_piece">string_piece</A> text, bool make_copy = false) = 0;
  virtual bool <A HREF="#tokenizer_next_sentence">next_sentence</A>(std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;* forms, std::vector&lt;<A HREF="#token_range">token_range</A>&gt;* tokens) = 0;

  static <A HREF="#tokenizer">tokenizer</A>* <A HREF="#tokenizer_new_vertical_tokenizer">new_vertical_tokenizer</A>();
};
</pre>

<p>
The <a href="#tokenizer"><code>tokenizer</code></a> class performs segmentation and tokenization of given text.
The class is <i>not</i> threadsafe.
</p>
<p>
The <a href="#tokenizer"><code>tokenizer</code></a> instances can be obtained either directly using the
static method <a href="#tokenizer_new_vertical_tokenizer"><code>new_vertical_tokenizer</code></a> or
through instances of <a href="#ner"><code>ner</code></a>.
</p>

<a id="tokenizer_set_text" name="tokenizer_set_text"></a>
<h3>6.6.1. tokenizer::set_text</h3>

<pre>
virtual void set_text(<A HREF="#string_piece">string_piece</A> text, bool make_copy = false) = 0;
</pre>

<p>
Set the text which is to be tokenized.
</p>
<p>
If <code>make_copy</code> is <code>false</code>, only a reference to the given text is
stored and the user has to make sure it exists until the tokenizer
is released or <code>set_text</code> is called again. If <code>make_copy</code>
is <code>true</code>, a copy of the given text is made and retained until the
tokenizer is released or <code>set_text</code> is called again.
</p>

<a id="tokenizer_next_sentence" name="tokenizer_next_sentence"></a>
<h3>6.6.2. tokenizer::next_sentence</h3>

<pre>
virtual bool next_sentence(std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;* forms, std::vector&lt;<A HREF="#token_range">token_range</A>&gt;* tokens) = 0;
</pre>

<p>
Locate and return next sentence of the given text. Returns <code>true</code> when successful and <code>false</code> when
there are no more sentences in the given text. The arguments are filled with found tokens if not <code>NULL</code>.
The <code>forms</code> contain token ranges in bytes of UTF-8 encoding, the <code>tokens</code> contain token ranges
in Unicode characters.
</p>

<a id="tokenizer_new_vertical_tokenizer" name="tokenizer_new_vertical_tokenizer"></a>
<h3>6.6.3. tokenizer::new_vertical_tokenizer</h3>

<pre>
static <A HREF="#tokenizer">tokenizer</A> new_vertical_tokenizer();
</pre>

<p>
Returns a new instance of a vertical tokenizer, which considers every line to
be one token, with empty line denoting end of sentence. The user should delete
the instance after use.
</p>

<a id="ner" name="ner"></a>
<h2>6.7. Class ner</h2>

<pre>
class ner {
 public:
  virtual ~ner() {}

  static <A HREF="#ner">ner</A>* <A HREF="#ner_load_cstring">load</A>(const char* fname);
  static <A HREF="#ner">ner</A>* <A HREF="#ner_load_istream">load</A>(istream&amp; is);

  virtual void <A HREF="#ner_recognize">recognize</A>(const std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;&amp; forms, std::vector&lt;<A HREF="#named_entity">named_entity</A>&gt;&amp; entities) const = 0;

  virtual void <A HREF="#ner_entity_types">entity_types</A>(std::vector&lt;std::string&gt;&amp; types) const = 0;
  virtual void <A HREF="#ner_gazetteers">gazetteers</A>(std::vector&lt;std::string&gt;&amp; gazetteers, std::vector&lt;int&gt;* gazetteer_types) const = 0;

  virtual <A HREF="#tokenizer">tokenizer</A>* <A HREF="#ner_new_tokenizer">new_tokenizer</A>() const = 0;
};
</pre>

<p>
A <a href="#ner"><code>ner</code></a> instance represents a named entity recognizer. All methods
are thread-safe.
</p>

<a id="ner_load_cstring" name="ner_load_cstring"></a>
<h3>6.7.1. ner::load(const char*)</h3>

<pre>
static <A HREF="#ner">ner</A>* load(const char* fname);
</pre>

<p>
Factory method constructor. Accepts C string with a file name of the model.
Returns a pointer to an instance of <a href="#ner"><code>ner</code></a> which the user should delete
after use.
</p>

<a id="ner_load_istream" name="ner_load_istream"></a>
<h3>6.7.2. ner::load(istream&amp;)</h3>

<pre>
static <A HREF="#ner">ner</A>* load(istream&amp; is);
</pre>

<p>
Factory method constructor. Accepts an input stream with the
model. Returns a pointer to an instance of <a href="#ner"><code>ner</code></a> which the user should
delete after use.
</p>

<a id="ner_recognize" name="ner_recognize"></a>
<h3>6.7.3. ner::recognize</h3>

<pre>
virtual void recognize(const std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;&amp; forms, std::vector&lt;<A HREF="#named_entity">named_entity</A>&gt;&amp; entities) const = 0;
</pre>

<p>
Perform named entity recognition on a tokenized sentence given in the <code>forms</code> argument.
The found entities are returned in the <code>entities</code> argument. The range of the
returned <a href="#named_entity">named_entity</a> is represented using form indices.
</p>

<a id="ner_entity_types" name="ner_entity_types"></a>
<h3>6.7.4. ner::entity_types</h3>

<pre>
virtual void entity_types(std::vector&lt;std::string&gt;&amp; types) const = 0;
</pre>

<p>
Return the entity types recognizable by the recognizer.
</p>

<a id="ner_gazetteers" name="ner_gazetteers"></a>
<h3>6.7.5. ner::gazetteers</h3>

<pre>
virtual void gazetteers(std::vector&lt;std::string&gt;&amp; gazetteers, std::vector&lt;int&gt;* gazetteer_types) const = 0;
</pre>

<p>
Return a list of gazetteers stored in the recognizer, optionally together with
corresponding named entity types. Currently only gazetteers from the
<code>GazetteersEnhanced</code> feature template are returned.
</p>

<a id="ner_new_tokenizer" name="ner_new_tokenizer"></a>
<h3>6.7.6. ner::new_tokenizer</h3>

<pre>
virtual <A HREF="#tokenizer">tokenizer</A>* new_tokenizer() const = 0;
</pre>

<p>
Returns a new instance of a suitable tokenizer or <code>NULL</code> if no such tokenizer
exists. The user should delete it after use.
</p>

<a id="cpp_bindings_api" name="cpp_bindings_api"></a>
<h2>6.8. C++ Bindings API</h2>

<p>
Bindings for other languages than C++ are created using SWIG from the C++
bindings API, which is a slightly modified version of the native C++ API.
Main changes are replacement of <a href="#string_piece"><code>string_piece</code></a> type by native
strings and removal of methods using <code>istream</code>. Here is the C++ bindings API
declaration:
</p>

<a id="bindings_helper_structures" name="bindings_helper_structures"></a>
<h3>6.8.1. Helper Structures</h3>

<pre>
typedef vector&lt;string&gt; Forms;

struct TokenRange {
  size_t start;
  size_t length;
};
typedef vector&lt;TokenRange&gt; TokenRanges;

struct NamedEntity {
  size_t start;
  size_t length;
  string type;

  NamedEntity();
  NamedEntity(size_t start, size_t length, const string&amp; type);
};
typedef vector&lt;NamedEntity&gt; NamedEntities;
</pre>

<a id="bindings_main_classes" name="bindings_main_classes"></a>
<h3>6.8.2. Main Classes</h3>

<pre>
class Version {
 public:
  unsigned major;
  unsigned minor;
  unsigned patch;
  string prerelease;

  static Version current();
};

class Tokenizer {
 public:
  virtual void setText(const char* text);
  virtual bool nextSentence(Forms* forms, TokenRanges* tokens);

  static Tokenizer* newVerticalTokenizer();
};

class Ner {
  static ner* load(const char* fname);

  virtual void recognize(Forms&amp; forms, NamedEntities&amp; entities) const;

  virtual void entityTypes(Forms&amp; types) const;
  virtual void gazetteers(Forms&amp; gazetteers, Ints&amp; gazetteer_types) const;

  virtual Tokenizer* newTokenizer() const;
};
</pre>

<a id="csharp_bindings" name="csharp_bindings"></a>
<h2>6.9. C# Bindings</h2>

<p>
NameTag library bindings is available in the <code>Ufal.NameTag</code> namespace.
</p>
<p>
The bindings is a straightforward conversion of the <code>C++</code> bindings API.
The bindings requires native C++ library <code>libnametag_csharp</code> (called
<code>nametag_csharp</code> on Windows).
</p>
<p>
See also <a href="https://github.com/ufal/nametag/tree/master/bindings/csharp/examples">C# binding example usage</a>. 
</p>

<a id="java_bindings" name="java_bindings"></a>
<h2>6.10. Java Bindings</h2>

<p>
NameTag library bindings is available in the <code>cz.cuni.mff.ufal.nametag</code>
package.
</p>
<p>
The bindings is a straightforward conversion of the <code>C++</code> bindings API.
Vectors do not have native Java interface, see
<code>cz.cuni.mff.ufal.nametag.Forms</code> class for reference. Also, class members
are accessible and modifiable using using <code>getField</code> and <code>setField</code>
wrappers.
</p>
<p>
The bindings require native C++ library <code>libnametag_java</code> (called
<code>nametag_java</code> on Windows). If the library is found in the current
directory, it is used, otherwise standard library search process is used.
The path to the C++ library can also be specified using static
<code>nametag_java.setLibraryPath(String path)</code> call (before the first call
inside the C++ library, of course).
</p>
<p>
See also <a href="https://github.com/ufal/nametag/tree/master/bindings/java/examples">Java binding example usage</a>. 
</p>

<a id="perl_bindings" name="perl_bindings"></a>
<h2>6.11. Perl Bindings</h2>

<p>
NameTag library bindings is available in the
<a href="http://search.cpan.org/~straka/Ufal-NameTag/"><code>Ufal::NameTag</code></a> package.
The classes can be imported into the current namespace using the <code>:all</code>
export tag.
</p>
<p>
The bindings is a straightforward conversion of the <code>C++</code> bindings API.
Vectors do not have native Perl interface, see <code>Ufal::NameTag::Forms</code> for
reference. Static methods and enumerations are available only through the
module, not through object instance.
</p>
<p>
See also <a href="https://github.com/ufal/nametag/tree/master/bindings/perl/examples">Perl binding example usage</a>. 
</p>

<a id="python_bindings" name="python_bindings"></a>
<h2>6.12. Python Bindings</h2>

<p>
NameTag library bindings is available in the
<a href="http://pypi.python.org/pypi/ufal.nametag"><code>ufal.nametag</code></a> module.
</p>
<p>
The bindings is a straightforward conversion of the <code>C++</code> bindings API.
In Python 2, strings can be both <code>unicode</code> and UTF-8 encoded <code>str</code>, and the
library always produces <code>unicode</code>. In Python 3, strings must be only <code>str</code>.
</p>
<p>
See also <a href="https://github.com/ufal/nametag/tree/master/bindings/python/examples">Python binding example usage</a>. 
</p>

<a id="contact" name="contact"></a>
<h1>7. Contact</h1>

<p style="margin-bottom:0">
Authors:
</p>
<ul style="margin-top:0">
<li><a href="http://ufal.mff.cuni.cz/milan-straka">Milan Straka</a>, <a href="mailto:straka@ufal.mff.cuni.cz">straka@ufal.mff.cuni.cz</a>
</li>
<li><a href="http://ufal.mff.cuni.cz/jana-strakova">Jana Straková</a>, <a href="mailto:strakova@ufal.mff.cuni.cz">strakova@ufal.mff.cuni.cz</a>
</li>
</ul>

<p>
<a href="http://ufal.mff.cuni.cz/nametag">NameTag website</a>.
</p>
<p>
<a href="http://hdl.handle.net/11858/00-097C-0000-0023-43CE-E">NameTag LINDAT/CLARIN entry</a>.
</p>

<a id="nametag_acknowledgements" name="nametag_acknowledgements"></a>
<h1>8. Acknowledgements</h1>

<p>
This work has been using language resources developed and/or stored and/or distributed by the LINDAT/CLARIN project of the Ministry of Education of the Czech Republic (project LM2010013).
</p>
<p>
Acknowledgements for individual language models are listed in <a href="#users_manual">NameTag User's Manual</a>.
</p>

<a id="publications" name="publications"></a>
<h2>8.1. Publications</h2>

<ul>
<li>(Straková et al. 2014) Straková Jana, Straka Milan and Hajič Jan. <i><a href="http://www.aclweb.org/anthology/P/P14/P14-5003.pdf">Open-Source Tools for Morphology, Lemmatization, POS Tagging and Named Entity Recognition.</a></i> In Proceedings of 52nd Annual Meeting of the Association for Computational Linguistics: System Demonstrations, pages 13-18, Baltimore, Maryland, June 2014. Association for Computational Linguistics.
<p></p>
</li>
<li>(Straková et al. 2013) Straková Jana, Straka Milan, Hajič Jan: <i><a href="http://ufal.mff.cuni.cz/~straka/papers/2013-tsd_ner.pdf">A New State-of-The-Art Czech Named Entity Recognizer</a>.</i> In: Lecture Notes in Computer Science, Vol. 8082, Text, Speech and Dialogue: 16th International Conference, TSD 2013. Proceedings, Copyright © Springer Verlag, Berlin / Heidelberg, ISBN 978-3-642-40584-6, ISSN 0302-9743, pp. 68-75, 2013
</li>
</ul>

<a id="bibtex_for_referencing" name="bibtex_for_referencing"></a>
<h2>8.2. Bibtex for referencing</h2>

<pre>
@InProceedings{strakova14,
  author    = {Strakov\'{a}, Jana  and  Straka, Milan  and  Haji\v{c}, Jan},
  title     = {Open-{S}ource {T}ools for {M}orphology, {L}emmatization, {POS} {T}agging and {N}amed {E}ntity {R}ecognition},
  booktitle = {Proceedings of 52nd Annual Meeting of the Association for Computational Linguistics: System Demonstrations},
  month     = {June},
  year      = {2014},
  address   = {Baltimore, Maryland},
  publisher = {Association for Computational Linguistics},
  pages     = {13--18},
  url       = {http://www.aclweb.org/anthology/P/P14/P14-5003.pdf}
}
</pre>

<a id="persistent_identifier" name="persistent_identifier"></a>
<h2>8.3. Persistent Identifier</h2>

<p>
If you prefer to reference NameTag by a persistent identifier (PID),
you can use <code>http://hdl.handle.net/11858/00-097C-0000-0023-43CE-E</code>.
</p>
</div>

<!-- html code generated by txt2tags 2.6 (http://txt2tags.org) -->
<!-- cmdline: txt2tags -t html -\-toc -\-enum-title -o nametag.html -C t2t_docsys/t2t_docsys_manual.conf nametag.t2t -->
</body></html>
